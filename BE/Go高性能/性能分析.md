# benchmark 基准测试 | Go 语言高性能编程

## 2.4 提升准确性
```
// fib_test.go
package main

import "testing"

func BenchmarkFib(b *testing.B) {
	for n := 0; n < b.N; n++ {
		fib(30) // run fib(30) b.N times
	}
}
```
```
$ go test -bench='Fib$' -benchtime=5s -cpu=2,4 -count=3 .
```
测试以Fib开头的性能测试类，测试5s，3轮,分别用2、4核; -benchtime=30x 即执行30次

```
BenchmarkFib-8               202           5980669 ns/op
```
测试使用了8核，共执行202次，每次 xx ns
## 2.5 内存分配情况
```
// generate_test.go
package main

import (
	"math/rand"
	"testing"
	"time"
)

func generateWithCap(n int) []int {
	rand.Seed(time.Now().UnixNano())
	nums := make([]int, 0, n)
	for i := 0; i < n; i++ {
		nums = append(nums, rand.Int())
	}
	return nums
}

func generate(n int) []int {
	rand.Seed(time.Now().UnixNano())
	nums := make([]int, 0)
	for i := 0; i < n; i++ {
		nums = append(nums, rand.Int())
	}
	return nums
}

func BenchmarkGenerateWithCap(b *testing.B) {
	for n := 0; n < b.N; n++ {
		generateWithCap(1000000)
	}
}

func BenchmarkGenerate(b *testing.B) {
	for n := 0; n < b.N; n++ {
		generate(1000000)
	}
}
```
```
go test -bench='Generate'  -benchmem .


goos: darwin
goarch: amd64
pkg: example
BenchmarkGenerateWithCap-8  43  24335658 ns/op  8003641 B/op    1 allocs/op
BenchmarkGenerate-8         33  30403687 ns/op  45188395 B/op  40 allocs/op
PASS
ok      example 2.121s
```
- 参数可以度量内存分配的次数，不合理的切片容量会导致内存重新分配。
- 使用切片容量设置可以一次性申请所需的内存，比不设置切片容量少耗时20%。

## 2.6 测试不同的输入
- 利用benchmark验证函数复杂度的简单方式是构造不同的输入。
- 实现辅助函数允许传入参数i，并构造了4个不同输入的benchmark用例。
- 结果表明输入变为原来的10倍，函数每次调用的时长也差不多是原来的10倍，说明复杂度是线性的。

## 3 benchmark 注意事项
### 3.1 ResetTimer
- 如果准备工作比较耗时，在benchmark开始前需要忽略这部分代码的耗时。
- 使用ResetTimer屏蔽耗时准备任务后，运行结果恢复正常。

### 3.2 StopTimer & StartTimer
- 在每次函数调用前后需要准备工作和清理工作时，可以使用StopTimer暂停计时和StartTimer开始计时。

附：推荐与参考
- Go语言笔试面试题汇总
- 七天用Go从零实现系列
- How to write benchmarks in Go

[edit this page](https://github.com/geektutu/high-performance-go/blob/master/charpter-1/hpg-benchmark.md) last updated at 2023-11-
